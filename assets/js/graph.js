// Graph Visualization using D3.js
// This creates an interactive force-directed graph

class KnowledgeGraph {
    constructor(containerId) {
        this.container = d3.select(`#${containerId}`);
        this.width = document.getElementById(containerId).clientWidth;
        this.height = document.getElementById(containerId).clientHeight;
        this.nodes = [];
        this.links = [];
        this.simulation = null;
        this.svg = null;
        this.activeFilters = new Set();

        this.init();
    }

    init() {
        // Create SVG
        this.svg = this.container
            .attr('width', this.width)
            .attr('height', this.height);

        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                this.g.attr('transform', event.transform);
            });

        this.svg.call(zoom);

        // Create container group for zoom/pan
        this.g = this.svg.append('g');

        // Create force simulation
        this.simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(d => d.id).distance(150))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(this.width / 2, this.height / 2))
            .force('collision', d3.forceCollide().radius(50));

        // Load data
        this.loadData();
    }

    async loadData() {
        try {
            const rawData = await this.fetchGraphData();
            const { nodes, links, warnings } = this.sanitizeGraphData(rawData);

            if (warnings.length) {
                console.warn('Graph data warnings:', warnings);
            }

            this.nodes = nodes;
            this.links = links;

            // Update stats
            this.updateStats();

            if (!this.nodes.length) {
                this.showEmptyState('No graph data available. Add notes and regenerate the graph.');
                return;
            }

            // Render graph
            this.render();

            // Hide loading spinner
            this.hideLoadingState();
        } catch (error) {
            console.error('Error loading graph data:', error);
            this.showError(error?.message);
        }
    }

    async fetchGraphData() {
        // Load data from JSON file generated by generate-data.py
        try {
            const response = await fetch('/assets/data/notes.json', { cache: 'no-cache' });
            if (!response.ok) {
                throw new Error(`Could not load notes data (status ${response.status})`);
            }

            let data;
            try {
                data = await response.json();
            } catch (parseError) {
                throw new Error('Notes data is not valid JSON');
            }

            if (!data || typeof data !== 'object') {
                throw new Error('Notes data is empty or malformed');
            }

            return {
                nodes: Array.isArray(data.nodes) ? data.nodes : [],
                links: Array.isArray(data.links) ? data.links : [],
            };
        } catch (error) {
            console.warn('Could not load notes.json:', error);
            throw error;
        }
    }

    sanitizeGraphData(data) {
        const warnings = [];
        const nodes = [];

        const rawNodes = Array.isArray(data.nodes) ? data.nodes : [];
        rawNodes.forEach((node, index) => {
            const hasId = node && node.id;
            const hasCategory = node && node.category;
            if (!hasId || !hasCategory) {
                warnings.push(`Node at index ${index} is missing a required field (id/category).`);
                return;
            }

            const related = Array.isArray(node.related) ? node.related : [];
            if (!Array.isArray(node.related)) {
                warnings.push(`Node '${node.id}' has an invalid related list; defaulting to empty array.`);
            }

            const sanitizedNode = { ...node, related };
            nodes.push(sanitizedNode);
        });

        const validIds = new Set(nodes.map(n => n.id));
        const links = [];
        const rawLinks = Array.isArray(data.links) ? data.links : [];

        rawLinks.forEach((link, index) => {
            const source = link && link.source;
            const target = link && link.target;
            if (!source || !target) {
                warnings.push(`Link at index ${index} is missing source/target.`);
                return;
            }

            if (!validIds.has(source) || !validIds.has(target)) {
                warnings.push(`Link '${source}' -> '${target}' references missing nodes and was skipped.`);
                return;
            }

            links.push({ ...link });
        });

        return { nodes, links, warnings };
    }

    render() {
        // Create links
        const link = this.g.append('g')
            .selectAll('line')
            .data(this.links)
            .enter()
            .append('line')
            .attr('class', 'link')
            .attr('stroke-width', 2);

        // Create nodes
        const node = this.g.append('g')
            .selectAll('g')
            .data(this.nodes)
            .enter()
            .append('g')
            .attr('class', d => `node category-${d.category.toLowerCase()}`)
            .call(this.drag());

        // Add circles to nodes
        node.append('circle')
            .attr('r', 30)
            .attr('fill', d => this.getCategoryColor(d.category))
            .attr('stroke', d => this.getCategoryStroke(d.category));

        // Add labels to nodes
        node.append('text')
            .text(d => d.name)
            .attr('dy', 45)
            .attr('text-anchor', 'middle');

        // Add interactions
        node.on('click', (event, d) => this.onNodeClick(event, d))
            .on('mouseenter', (event, d) => this.onNodeHover(event, d))
            .on('mouseleave', () => this.onNodeLeave());

        // Update simulation
        this.simulation
            .nodes(this.nodes)
            .on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

        this.simulation.force('link').links(this.links);

        // Store references
        this.linkElements = link;
        this.nodeElements = node;
    }

    drag() {
        return d3.drag()
            .on('start', (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on('drag', (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on('end', (event, d) => {
                if (!event.active) this.simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            });
    }

    onNodeClick(event, node) {
        // Navigate to note viewer page with note ID
        window.location.href = `/notes/note.html?id=${node.id}`;
    }

    onNodeHover(event, node) {
        // Highlight connected nodes
        this.highlightConnections(node);

        // Show tooltip
        this.showTooltip(event, node);
    }

    onNodeLeave() {
        // Remove highlights
        this.nodeElements.classed('dimmed', false);
        this.linkElements.classed('dimmed', false).classed('highlighted', false);

        // Hide tooltip
        this.hideTooltip();
    }

    highlightConnections(node) {
        const connectedNodes = new Set();
        connectedNodes.add(node.id);

        // Find connected nodes
        this.links.forEach(link => {
            if (link.source.id === node.id) connectedNodes.add(link.target.id);
            if (link.target.id === node.id) connectedNodes.add(link.source.id);
        });

        // Dim non-connected nodes
        this.nodeElements.classed('dimmed', d => !connectedNodes.has(d.id));

        // Highlight connected links
        this.linkElements
            .classed('dimmed', d => d.source.id !== node.id && d.target.id !== node.id)
            .classed('highlighted', d => d.source.id === node.id || d.target.id === node.id);
    }

    showTooltip(event, node) {
        const tooltip = document.getElementById('nodeTooltip');
        tooltip.classList.remove('hidden');

        tooltip.querySelector('.tooltip-title').textContent = node.name;
        tooltip.querySelector('.tooltip-category').textContent = node.category.toUpperCase();
        tooltip.querySelector('.tooltip-description').textContent = node.description;

        // Position tooltip
        tooltip.style.left = `${event.pageX + 10}px`;
        tooltip.style.top = `${event.pageY + 10}px`;
    }

    hideTooltip() {
        document.getElementById('nodeTooltip').classList.add('hidden');
    }

    getCategoryColor(category) {
        const palette = (typeof window !== 'undefined' && window.categoryPalette) || {};
        const colors = {
            'genai': '#6366f1',
            'edge-ml': '#8b5cf6',
            'deep-learning': '#ec4899',
            'ml': '#14b8a6',
            'conference': '#f59e0b',
            'visualization': '#06b6d4',
            'default': '#6b7280'
        };
        return palette[category] || colors[category] || colors.default;
    }

    getCategoryStroke(category) {
        const palette = (typeof window !== 'undefined' && window.categoryPalette) || {};
        const strokes = {
            'ai': '#4f46e5',
            'ml': '#7c3aed',
            'programming': '#db2777',
            'data': '#0d9488',
            'web': '#d97706',
            'math': '#0891b2',
            'default': '#4b5563'
        };

        if (palette[category]) return palette[category];
        return strokes[category] || strokes.default;
    }

    updateStats() {
        document.getElementById('nodeCount').textContent = this.nodes.length;
        document.getElementById('connectionCount').textContent = this.links.length;
    }

    filterByCategory(categories) {
        const normalize = (category) => (category || '').toString().trim().toLowerCase();
        const normalizedFilters = new Set(Array.from(categories || []).map(normalize));
        const hasFilters = normalizedFilters.size > 0;
        this.activeFilters = new Set(normalizedFilters);

        const isVisible = (category) => !hasFilters || normalizedFilters.has(normalize(category));

        if (!this.nodeElements || !this.linkElements) return;

        this.nodeElements
            .classed('dimmed', d => hasFilters && !isVisible(d.category))
            .style('opacity', d => hasFilters && !isVisible(d.category) ? 0.2 : 1)
            .style('pointer-events', d => hasFilters && !isVisible(d.category) ? 'none' : 'all')
            .attr('display', d => hasFilters && !isVisible(d.category) ? 'none' : 'block');

        this.linkElements
            .classed('dimmed', d => hasFilters && (!isVisible(d.source.category) || !isVisible(d.target.category)))
            .style('opacity', d => hasFilters && (!isVisible(d.source.category) || !isVisible(d.target.category)) ? 0.1 : 0.6)
            .attr('display', d => hasFilters && (!isVisible(d.source.category) || !isVisible(d.target.category)) ? 'none' : 'block');

        // Restart or reheat simulation so layout stabilizes after hiding elements
        this.simulation.alpha(0.35).restart();
    }

    hideLoadingState() {
        const spinner = document.getElementById('loadingSpinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
    }

    showEmptyState(message) {
        const spinner = document.getElementById('loadingSpinner');
        if (spinner) {
            spinner.innerHTML = `<p style="color: #6b7280;">${message || 'No graph data found.'}</p>`;
            spinner.style.display = 'block';
        }

        if (this.svg) {
            this.svg.style('display', 'none');
        }
    }

    showError(message) {
        const spinner = document.getElementById('loadingSpinner');
        if (spinner) {
            spinner.innerHTML = `<p style="color: red;">${message || 'Error loading graph data. Please refresh the page.'}</p>`;
            spinner.style.display = 'block';
        }

        if (this.svg) {
            this.svg.style('display', 'none');
        }
    }
}

// Initialize graph when page loads
let graph;
document.addEventListener('DOMContentLoaded', () => {
    graph = new KnowledgeGraph('graph');
});